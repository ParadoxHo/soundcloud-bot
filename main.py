# -*- coding: utf-8 -*-
import os
import sys
import json
import logging
import tempfile
import re
import random
import asyncio
import shutil
from datetime import datetime, timedelta
from pathlib import Path
import concurrent.futures

# ==================== CONFIG ====================
BOT_TOKEN = os.environ.get('BOT_TOKEN')
ADMIN_IDS = os.environ.get('ADMIN_IDS', '').split(',')

if not BOT_TOKEN:
    print("‚ùå –û—à–∏–±–∫–∞: BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    print("üìù –î–æ–±–∞–≤—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é BOT_TOKEN –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Railway")
    sys.exit(1)

ADMIN_IDS = [id.strip() for id in ADMIN_IDS if id.strip()]

if not ADMIN_IDS:
    print("‚ö†Ô∏è  –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: ADMIN_IDS –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ê–¥–º–∏–Ω-–∫–æ–º–∞–Ω–¥—ã –æ—Ç–∫–ª—é—á–µ–Ω—ã.")
else:
    print(f"‚úÖ –ê–¥–º–∏–Ω—ã –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã: {ADMIN_IDS}")

RESULTS_PER_PAGE = 10
DATA_FILE = Path('user_data.json')
CHARTS_FILE = Path('charts_cache.json')
MAX_FILE_SIZE_MB = 50

MAX_CONCURRENT_DOWNLOADS = 3
DOWNLOAD_TIMEOUT = 180
SEARCH_TIMEOUT = 30

DYNAMIC_TIMEOUTS = {
    'short_track': 30,
    'medium_track': 60, 
    'long_track': 120,
    'search': 25
}

SIMPLE_DOWNLOAD_OPTS = {
    'format': 'bestaudio[ext=mp3]/bestaudio[ext=m4a]/bestaudio[ext=ogg]/bestaudio[ext=wav]/bestaudio[ext=flac]/bestaudio/best',
    'outtmpl': os.path.join(tempfile.gettempdir(), '%(id)s.%(ext)s'),
    'quiet': True,
    'no_warnings': True,
    'retries': 3,
    'fragment_retries': 3,
    'skip_unavailable_fragments': True,
    'noprogress': True,
    'nopart': True,
    'nooverwrites': True,
    'noplaylist': True,
    'max_filesize': 45000000,
    'ignoreerrors': True,
    'ignore_no_formats_error': True,
    'socket_timeout': 30,
}

FAST_INFO_OPTS = {
    'quiet': True,
    'no_warnings': True,
    'simulate': True,
    'format': 'bestaudio/best',
    'skip_download': True,
    'noplaylist': True,
    'extract_flat': True,
    'socket_timeout': 15,
    'ignoreerrors': True,
}

DURATION_FILTERS = {
    'no_filter': '–ë–µ–∑ —Ñ–∏–ª—å—Ç—Ä–∞',
    'up_to_5min': '–î–æ 5 –º–∏–Ω—É—Ç',
    'up_to_10min': '–î–æ 10 –º–∏–Ω—É—Ç', 
    'up_to_20min': '–î–æ 20 –º–∏–Ω—É—Ç',
}

SMART_PLAYLISTS = {
    'work_focus': {
        'name': 'üíº –§–æ–∫—É—Å –∏ —Ä–∞–±–æ—Ç–∞',
        'queries': ['lo fi study', 'focus music', 'ambient study', 'coding music', 'deep work'],
        'description': '–ú—É–∑—ã–∫–∞ –¥–ª—è –∫–æ–Ω—Ü–µ–Ω—Ç—Ä–∞—Ü–∏–∏ –∏ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏'
    },
    'workout': {
        'name': 'üí™ –¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞',
        'queries': ['workout music', 'gym motivation', 'edm workout', 'hip hop workout', 'energy music'],
        'description': '–≠–Ω–µ—Ä–≥–∏—á–Ω–∞—è –º—É–∑—ã–∫–∞ –¥–ª—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫'
    },
    'relax': {
        'name': 'üòå –†–µ–ª–∞–∫—Å',
        'queries': ['chillhop', 'ambient relax', 'piano relax', 'meditation music', 'calm music'],
        'description': '–°–ø–æ–∫–æ–π–Ω–∞—è –º—É–∑—ã–∫–∞ –¥–ª—è —Ä–∞—Å—Å–ª–∞–±–ª–µ–Ω–∏—è'
    },
    'party': {
        'name': 'üéâ –í–µ—á–µ—Ä–∏–Ω–∫–∞', 
        'queries': ['party hits', 'dance music', 'club mix', 'top hits', 'festival music'],
        'description': '–¢–∞–Ω—Ü–µ–≤–∞–ª—å–Ω–∞—è –º—É–∑—ã–∫–∞ –¥–ª—è –≤–µ—á–µ—Ä–∏–Ω–æ–∫'
    },
    'road_trip': {
        'name': 'üöó –ü—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ',
        'queries': ['road trip', 'driving music', 'travel mix', 'adventure music', 'scenic drive'],
        'description': '–ú—É–∑—ã–∫–∞ –¥–ª—è –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–π –∏ –ø–æ–µ–∑–¥–æ–∫'
    }
}

RANDOM_SEARCHES = [
    'lo fi beats', 'chillhop', 'deep house', 'synthwave', 'indie rock',
    'electronic music', 'jazz lounge', 'ambient', 'study music',
    'focus music', 'relaxing music', 'instrumental', 'acoustic',
    'piano covers', 'guitar music', 'vocal trance', 'dubstep',
    'tropical house', 'future bass', 'retro wave', 'city pop',
    'latin music', 'reggeaton', 'k-pop', 'j-pop', 'classical piano',
    'orchestral', 'film scores', 'video game music', 'retro gaming',
    'chill beats', 'lounge music', 'smooth jazz', 'progressive house',
    'techno music', 'trance music', 'hip hop instrumental', 'rap beats'
]

POPULAR_SEARCHES = [
    'the weeknd', 'taylor swift', 'bad bunny', 'ariana grande', 'drake',
    'billie eilish', 'ed sheeran', 'dualipa', 'post malone', 'kanye west', 
    'coldplay', 'maroon 5', 'bruno mars', 'adele', 'justin bieber',
    'kendrick lamar', 'travis scott', 'doja cat', 'olivia rodrigo', 'harry styles'
]

# ==================== IMPORT TELEGRAM & YT-DLP ====================
try:
    from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
    from telegram.ext import (
        Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, 
        ContextTypes
    )
    import yt_dlp
    print("‚úÖ –í—Å–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã")
except ImportError as exc:
    print(f"‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: {exc}")
    print("üì¶ –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏...")
    os.system("pip install python-telegram-bot yt-dlp")
    try:
        from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
        from telegram.ext import (
            Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, 
            ContextTypes
        )
        import yt_dlp
        print("‚úÖ –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")
    except ImportError as exc2:
        print(f"‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ –ø–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: {exc2}")
        sys.exit(1)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('bot.log', encoding='utf-8')
    ]
)
logger = logging.getLogger(__name__)

# ==================== USER DATA STORAGE ====================
user_data = {}
charts_cache = {}

def load_data():
    global user_data, charts_cache
    if DATA_FILE.exists():
        try:
            with open(DATA_FILE, 'r', encoding='utf-8') as f:
                user_data = json.load(f)
        except Exception as e:
            logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å {DATA_FILE}: {e}")
            user_data = {}
    else:
        user_data = {}

    if CHARTS_FILE.exists():
        try:
            with open(CHARTS_FILE, 'r', encoding='utf-8') as f:
                charts_cache = json.load(f)
        except Exception as e:
            logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å {CHARTS_FILE}: {e}")
            charts_cache = {}
    else:
        charts_cache = {}

def save_data():
    try:
        with open(DATA_FILE, 'w', encoding='utf-8') as f:
            json.dump(user_data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: {e}")

def save_charts_cache():
    try:
        with open(CHARTS_FILE, 'w', encoding='utf-8') as f:
            json.dump(charts_cache, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫—ç—à–∞ —á–∞—Ä—Ç–æ–≤: {e}")

load_data()

# ==================== –ê–î–ú–ò–ù-–§–£–ù–ö–¶–ò–ò ====================

def is_admin(user_id: str) -> bool:
    return str(user_id) in ADMIN_IDS

async def require_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    if not is_admin(user_id):
        await update.message.reply_text("‚ùå –ö–æ–º–∞–Ω–¥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
        return False
    return True

async def admin_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await require_admin(update, context):
        return

    user_count = len([k for k in user_data.keys() if not k.startswith('_')])
    total_downloads = sum(stats.get('downloads', 0) for stats in user_data.get('_user_stats', {}).values())
    total_searches = sum(stats.get('searches', 0) for stats in user_data.get('_user_stats', {}).values())

    text = f"""üìä <b>–ê–¥–º–∏–Ω —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</b>

üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {user_count}
üì• –í—Å–µ–≥–æ —Å–∫–∞—á–∏–≤–∞–Ω–∏–π: {total_downloads}
üîç –í—Å–µ–≥–æ –ø–æ–∏—Å–∫–æ–≤: {total_searches}
üíæ –†–∞–∑–º–µ—Ä user_data: {len(str(user_data))} —Å–∏–º–≤–æ–ª–æ–≤
üìà –ö—ç—à —á–∞—Ä—Ç–æ–≤: {len(charts_cache.get('data', {}))} –∑–∞–ø—Ä–æ—Å–æ–≤
üîß –ê–¥–º–∏–Ω–æ–≤: {len(ADMIN_IDS)}"""

    await update.message.reply_text(text, parse_mode='HTML')

async def admin_cleanup(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await require_admin(update, context):
        return

    cleared_users = 0
    current_time = datetime.now()

    for user_id in list(user_data.keys()):
        if user_id.startswith('_') or user_id in ADMIN_IDS:
            continue

        user_stats = user_data.get('_user_stats', {}).get(user_id, {})
        last_search = user_stats.get('last_search')

        if last_search:
            try:
                last_active = datetime.strptime(last_search, '%d.%m.%Y %H:%M')
                if (current_time - last_active).days > 30:
                    del user_data[user_id]
                    if user_id in user_data.get('_user_stats', {}):
                        del user_data['_user_stats'][user_id]
                    cleared_users += 1
            except ValueError:
                del user_data[user_id]
                cleared_users += 1
        else:
            del user_data[user_id]
            cleared_users += 1

    save_data()

    await update.message.reply_text(
        f"‚úÖ –û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n"
        f"üóë –£–¥–∞–ª–µ–Ω–æ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {cleared_users}\n"
        f"üë• –û—Å—Ç–∞–ª–æ—Å—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {len([k for k in user_data.keys() if not k.startswith('_')])}"
    )

async def admin_files(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await require_admin(update, context):
        return

    try:
        user_data_size = os.path.getsize('user_data.json') if os.path.exists('user_data.json') else 0
        charts_cache_size = os.path.getsize('charts_cache.json') if os.path.exists('charts_cache.json') else 0

        text = f"""üìÅ <b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ñ–∞–π–ª–∞—Ö</b>

user_data.json: {user_data_size / 1024:.1f} KB
charts_cache.json: {charts_cache_size / 1024:.1f} KB
–í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {len(user_data)}"""

        await update.message.reply_text(text, parse_mode='HTML')

    except Exception as e:
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")

async def admin_help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await require_admin(update, context):
        return

    text = """üîß <b>–ê–¥–º–∏–Ω –∫–æ–º–∞–Ω–¥—ã</b>

/admin_stats - üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞
/admin_cleanup - üóë –û—á–∏—Å—Ç–∫–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π  
/admin_files - üìÅ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ñ–∞–π–ª–∞—Ö
/admin_help - ‚ùì –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞"""

    await update.message.reply_text(text, parse_mode='HTML')

def setup_admin_commands(app):
    if ADMIN_IDS:
        app.add_handler(CommandHandler('admin_stats', admin_stats))
        app.add_handler(CommandHandler('admin_cleanup', admin_cleanup))
        app.add_handler(CommandHandler('admin_files', admin_files))
        app.add_handler(CommandHandler('admin_help', admin_help))
        print("‚úÖ –ê–¥–º–∏–Ω-–∫–æ–º–∞–Ω–¥—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã")
    else:
        print("‚ö†Ô∏è  –ê–¥–º–∏–Ω-–∫–æ–º–∞–Ω–¥—ã –æ—Ç–∫–ª—é—á–µ–Ω—ã (ADMIN_IDS –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω)")

# ==================== –£–õ–£–ß–®–ï–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –£–í–ï–î–û–ú–õ–ï–ù–ò–ô ====================

class NotificationManager:
    @staticmethod
    async def send_progress(update, context, stage: str, track=None, **kwargs):
        stages = {
            'searching': "üîç –ò—â–µ–º —Ç—Ä–µ–∫–∏...",
            'downloading': "‚¨áÔ∏è –°–∫–∞—á–∏–≤–∞–µ–º –∞—É–¥–∏–æ...", 
            'processing': "üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ñ–∞–π–ª...",
            'sending': "üì§ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Telegram...",
            'success': "‚úÖ –ì–æ—Ç–æ–≤–æ!",
            'error': "‚ùå –û—à–∏–±–∫–∞"
        }
        
        message = stages.get(stage, "‚è≥ –†–∞–±–æ—Ç–∞–µ–º...")
        if track and stage != 'searching':
            title = track.get('title', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç—Ä–µ–∫')[:30]
            message = f"{message}\nüéµ {title}"
            
        try:
            if hasattr(update, 'callback_query') and update.callback_query:
                await update.callback_query.edit_message_text(message)
            else:
                await context.bot.send_message(
                    chat_id=update.effective_chat.id, 
                    text=message
                )
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")

# ==================== –û–°–ù–û–í–ù–û–ô –ö–õ–ê–°–° –ë–û–¢–ê ====================

class StableMusicBot:
    def __init__(self):
        self.user_stats = user_data.get('_user_stats', {})
        self.track_info_cache = {}
        self.download_semaphore = asyncio.Semaphore(MAX_CONCURRENT_DOWNLOADS)
        self.search_semaphore = asyncio.Semaphore(3)
        self.notifications = NotificationManager()
        logger.info('‚úÖ –ë–æ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω')

    def ensure_user(self, user_id: str):
        if str(user_id) not in user_data:
            user_data[str(user_id)] = {
                'filters': {'duration': 'no_filter', 'music_only': False},
                'search_results': [],
                'search_query': '',
                'current_page': 0,
                'total_pages': 0,
                'favorites': [],
                'search_history': [],
                'download_history': [],
                'download_queue': [],
                'random_track_result': [],
                'achievements': {},
                'preferences': {
                    'favorite_genres': [],
                    'disliked_genres': []
                }
            }
        if '_user_stats' not in user_data:
            user_data['_user_stats'] = {}
        if str(user_id) not in user_data['_user_stats']:
            user_data['_user_stats'][str(user_id)] = {
                'searches': 0,
                'downloads': 0,
                'first_seen': datetime.now().strftime('%d.%m.%Y %H:%M'),
                'last_search': None,
            }

    @staticmethod
    def clean_title(title: str) -> str:
        if not title:
            return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç—Ä–µ–∫'
        try:
            title = title.encode('utf-8').decode('utf-8')
        except:
            pass
        title = re.sub(r"ÓÄÅ.*?ÓÄÅ|ÓÄÅ.*?ÓÄÅ", '', title)
        tags = ['official video', 'official music video', 'lyric video', 'hd', '4k',
                '1080p', '720p', 'official audio', 'audio']
        for tag in tags:
            title = re.sub(tag, '', title, flags=re.IGNORECASE)
        return ' '.join(title.split()).strip()

    @staticmethod
    def format_duration(seconds) -> str:
        try:
            sec = int(float(seconds))
            minutes = sec // 60
            sec = sec % 60
            return f"{minutes:02d}:{sec:02d}"
        except Exception:
            return '00:00'

    async def check_file_size_before_download(self, url: str, track: dict) -> tuple:
        try:
            with yt_dlp.YoutubeDL(FAST_INFO_OPTS) as ydl:
                info = await asyncio.get_event_loop().run_in_executor(
                    None, lambda: ydl.extract_info(url, download=False)
                )

                file_size = 0
                if info and 'filesize' in info and info['filesize']:
                    file_size = info['filesize'] / (1024 * 1024)
                elif info and 'filesize_approx' in info and info['filesize_approx']:
                    file_size = info['filesize_approx'] / (1024 * 1024)

                duration = track.get('duration', 0)
                if duration > 1800:
                    can_download = file_size < (MAX_FILE_SIZE_MB * 0.7)
                else:
                    can_download = file_size < MAX_FILE_SIZE_MB

                return file_size, can_download

        except Exception as e:
            logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: {e}")
            return 0, True

    def _get_dynamic_timeout(self, track: dict) -> int:
        duration = track.get('duration', 0)
        if duration < 180:
            return DYNAMIC_TIMEOUTS['short_track']
        elif duration < 600:
            return DYNAMIC_TIMEOUTS['medium_track']
        else:
            return DYNAMIC_TIMEOUTS['long_track']

    async def _handle_large_file(self, update: Update, context: ContextTypes.DEFAULT_TYPE, track: dict, file_size: float):
        title = track.get('title', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç—Ä–µ–∫')
        artist = track.get('artist', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å')
        
        text = f"üì¶ <b>–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π</b>\n\n"
        text += f"üéµ <b>{title}</b>\n"
        text += f"üé§ {artist}\n"
        text += f"üíæ –†–∞–∑–º–µ—Ä: {file_size:.1f} MB\n\n"
        text += f"‚ö†Ô∏è <b>–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç {MAX_FILE_SIZE_MB} MB</b>\n\n"
        text += f"üéß –í—ã –º–æ–∂–µ—Ç–µ:\n‚Ä¢ –ü—Ä–æ—Å–ª—É—à–∞—Ç—å –æ–Ω–ª–∞–π–Ω\n‚Ä¢ –ù–∞–π—Ç–∏ –±–æ–ª–µ–µ –∫–æ—Ä–æ—Ç–∫—É—é –≤–µ—Ä—Å–∏—é"

        keyboard = [
            [InlineKeyboardButton('üéß –°–ª—É—à–∞—Ç—å –æ–Ω–ª–∞–π–Ω', url=track.get('webpage_url', ''))],
            [InlineKeyboardButton('üîç –ù–∞–π—Ç–∏ –¥—Ä—É–≥—É—é –≤–µ—Ä—Å–∏—é', callback_data=f'search_alt:{title}')],
            [InlineKeyboardButton('üé≤ –°–ª—É—á–∞–π–Ω—ã–π —Ç—Ä–µ–∫', callback_data='random_track')],
        ]

        if hasattr(update, 'callback_query') and update.callback_query:
            await update.callback_query.edit_message_text(
                text, 
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
        else:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )

    async def _find_compatible_audio_file(self, tmpdir: str) -> str:
        telegram_audio_extensions = ['.mp3', '.m4a', '.ogg', '.wav', '.flac']
        
        for file in os.listdir(tmpdir):
            file_ext = os.path.splitext(file)[1].lower()
            if file_ext in telegram_audio_extensions:
                logger.info(f"‚úÖ –ù–∞–π–¥–µ–Ω —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π —Ñ–∞–π–ª: {file}")
                return file
        
        logger.error(f"‚ùå –°–æ–≤–º–µ—Å—Ç–∏–º—ã–µ —Ñ–∞–π–ª—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤: {os.listdir(tmpdir)}")
        return None

    async def _send_audio_file(self, update: Update, context: ContextTypes.DEFAULT_TYPE, 
                             fpath: str, track: dict, actual_size_mb: float) -> bool:
        try:
            with open(fpath, 'rb') as f:
                await context.bot.send_audio(
                    chat_id=update.effective_chat.id,
                    audio=f,
                    title=(track.get('title') or '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç—Ä–µ–∫')[:64],
                    performer=(track.get('artist') or '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å')[:64],
                    caption=f"üéµ <b>{track.get('title', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç—Ä–µ–∫')}</b>\nüé§ {track.get('artist', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å')}\n‚è±Ô∏è {self.format_duration(track.get('duration'))}\nüíæ {actual_size_mb:.1f} MB",
                    parse_mode='HTML',
                )
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª–∞: {e}")
            return False

    async def _cleanup_temp_dir(self, tmpdir: str):
        max_retries = 3
        for attempt in range(max_retries):
            try:
                if os.path.exists(tmpdir):
                    shutil.rmtree(tmpdir, ignore_errors=True)
                    logger.info(f"‚úÖ –í—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –æ—á–∏—â–µ–Ω—ã (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1})")
                    break
                else:
                    break
            except Exception as e:
                logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—á–∏—Å—Ç–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}): {e}")
                if attempt < max_retries - 1:
                    await asyncio.sleep(1)

    async def download_and_send_track(self, update: Update, context: ContextTypes.DEFAULT_TYPE, track: dict) -> bool:
        url = track.get('webpage_url') or track.get('url')
        if not url:
            return False

        file_size_mb, can_download = await self.check_file_size_before_download(url, track)
        
        if not can_download:
            await self._handle_large_file(update, context, track, file_size_mb)
            return False

        async with self.download_semaphore:
            try:
                await self.notifications.send_progress(update, context, 'downloading', track)
                
                timeout = self._get_dynamic_timeout(track)
                
                return await asyncio.wait_for(
                    self.simple_download(update, context, track),
                    timeout=timeout
                )
            except asyncio.TimeoutError:
                logger.error(f"–¢–∞–π–º–∞—É—Ç —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Ç—Ä–µ–∫–∞: {track.get('title', 'Unknown')}")
                await self.notifications.send_progress(update, context, 'error', track)
                return False
            except Exception as e:
                logger.exception(f'–û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Ç—Ä–µ–∫–∞: {e}')
                await self.notifications.send_progress(update, context, 'error', track)
                return False

    async def simple_download(self, update: Update, context: ContextTypes.DEFAULT_TYPE, track: dict) -> bool:
        url = track.get('webpage_url') or track.get('url')
        if not url:
            return False

        loop = asyncio.get_event_loop()
        tmpdir = tempfile.mkdtemp()
        
        try:
            await self.notifications.send_progress(update, context, 'processing', track)
            
            ydl_opts = SIMPLE_DOWNLOAD_OPTS.copy()
            ydl_opts['outtmpl'] = os.path.join(tmpdir, '%(title).100s.%(ext)s')

            def download_track():
                try:
                    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                        return ydl.extract_info(url, download=True)
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è: {e}")
                    return None

            info = await asyncio.wait_for(
                loop.run_in_executor(None, download_track),
                timeout=DOWNLOAD_TIMEOUT - 30
            )

            if not info:
                return False

            audio_file = await self._find_compatible_audio_file(tmpdir)
            if not audio_file:
                return False

            fpath = os.path.join(tmpdir, audio_file)
            actual_size_mb = os.path.getsize(fpath) / (1024 * 1024)
            
            if actual_size_mb >= MAX_FILE_SIZE_MB:
                await self._handle_large_file(update, context, track, actual_size_mb)
                return False

            await self.notifications.send_progress(update, context, 'sending', track)

            success = await self._send_audio_file(update, context, fpath, track, actual_size_mb)
            
            if success:
                await self.notifications.send_progress(update, context, 'success', track)
                return True
            return False

        except asyncio.TimeoutError:
            logger.error(f"–¢–∞–π–º–∞—É—Ç –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏: {track.get('title', 'Unknown')}")
            return False
        except Exception as e:
            logger.exception(f'–û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è: {e}')
            return False
        finally:
            await self._cleanup_temp_dir(tmpdir)

    # ... (–æ—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∫–æ–¥–∞ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
    # –î–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞ –Ω–µ –¥—É–±–ª–∏—Ä—É—é –≤—Å–µ –º–µ—Ç–æ–¥—ã, –æ–Ω–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∏–∑ –≤–∞—à–µ–≥–æ –æ—Ä–∏–≥–∏–Ω–∞–ª–∞

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = update.effective_user
        self.ensure_user(user.id)

        await self.show_main_menu(update, context)
        save_data()

    async def show_main_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = update.effective_user
        
        text = f"üè† <b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>\n\n"
        text += f"üëã –ü—Ä–∏–≤–µ—Ç, {user.first_name}!\n\n"
        text += f"üéµ <b>–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:</b>"

        keyboard = [
            [
                InlineKeyboardButton('üé≤ –°–ª—É—á–∞–π–Ω—ã–π —Ç—Ä–µ–∫', callback_data='random_track'),
                InlineKeyboardButton('üîç –ü–æ–∏—Å–∫', callback_data='start_search')
            ],
            [
                InlineKeyboardButton('üéØ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏', callback_data='show_recommendations'),
                InlineKeyboardButton('üìä –¢–æ–ø —á–∞—Ä—Ç—ã', callback_data='show_charts')
            ],
            [
                InlineKeyboardButton('üé≠ –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ', callback_data='mood_playlists'),
                InlineKeyboardButton('‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏', callback_data='settings')
            ],
            [InlineKeyboardButton('‚ùå –û—Ç–º–µ–Ω–∏—Ç—å', callback_data='cancel_operation')]
        ]

        if update.callback_query:
            await update.callback_query.edit_message_text(
                text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )
        else:
            await update.message.reply_text(
                text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode='HTML'
            )

    async def handle_cancel(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞")
        await self.show_main_menu(update, context)

    def run(self):
        print('üöÄ –ó–∞–ø—É—Å–∫ —É–ª—É—á—à–µ–Ω–Ω–æ–≥–æ Music Bot...')

        app = Application.builder().token(BOT_TOKEN).build()

        app.add_handler(CommandHandler('start', self.start))
        app.add_handler(CommandHandler('search', self.search_command))
        app.add_handler(CommandHandler('random', self.random_track))
        app.add_handler(CommandHandler('settings', self.show_settings))

        setup_admin_commands(app)

        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_text))
        app.add_handler(CallbackQueryHandler(self.handle_callback))
        
        app.add_handler(CallbackQueryHandler(self.handle_cancel, pattern='^cancel_operation$'))

        async def set_commands(application):
            commands = [
                ('start', 'üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞'),
                ('search', 'üîç –ù–∞—á–∞—Ç—å –ø–æ–∏—Å–∫'),
                ('random', 'üé≤ –°–ª—É—á–∞–π–Ω—ã–π —Ç—Ä–µ–∫'),
                ('settings', '‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤'),
            ]

            await application.bot.set_my_commands(commands)
            print('‚úÖ –£–ª—É—á—à–µ–Ω–Ω–æ–µ –º–µ–Ω—é —Å –∫–æ–º–∞–Ω–¥–∞–º–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ!')

        app.post_init = set_commands

        print('‚úÖ –£–ª—É—á—à–µ–Ω–Ω—ã–π –±–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!')
        app.run_polling()

if __name__ == '__main__':
    bot = StableMusicBot()
    bot.run()
